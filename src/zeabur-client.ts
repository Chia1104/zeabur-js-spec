import { GATEWAY_ENDPOINT, GRAPHQL_ENDPOINT } from "./constants";
import {
  GraphQLClient,
  ClientError,
  type RequestOptions,
} from "graphql-request";
import {
  CREATE_PROJECT,
  CREATE_SERVICE,
  GET_ENVIRONMENTS,
  CREATE_DOMAIN,
} from "./query";
import type {
  CreateProjectResponse,
  CreateProjectVariables,
  CreateServiceResponse,
  CreateServiceVariables,
  GetEnvironmentResponse,
  GetEnvironmentVariables,
  CreateDomainResponse,
  CreateDomainVariables,
  DeployResponse,
  DeployVariables,
} from "./types";
import { RequestError } from "./error";
import ky, { HTTPError, type Options } from "ky";

export default class ZeaburClient {
  private clientSecret: string;

  constructor(clientSecret: string) {
    this.clientSecret = clientSecret;
  }

  private gqlRequest = (options?: RequestOptions) =>
    new GraphQLClient(GRAPHQL_ENDPOINT, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.clientSecret}`,
      },
      fetch,
    });

  private request = (options?: Options) =>
    ky.create({
      ...options,
      headers: {
        Authorization: `Bearer ${this.clientSecret}`,
      },
      prefixUrl: GATEWAY_ENDPOINT,
    });

  /**
   * create a project with the given region and random name
   * @param { CreateProjectVariables } { region }
   * @returns { Promise<string> } projectID
   * @throws { ClientError }
   */
  public createProject = async ({
    region,
  }: CreateProjectVariables): Promise<string> => {
    try {
      return (
        await this.gqlRequest().request<
          CreateProjectResponse,
          CreateProjectVariables
        >(CREATE_PROJECT, { region })
      ).createProject._id;
    } catch (error) {
      if (error instanceof ClientError) {
        console.error(error.response.errors);
        throw error;
      }
      console.error("Unexpected error: ", error);
      throw error;
    }
  };

  /**
   * create a service with the given projectID, template and name
   * @param { CreateServiceVariables } { projectID, template, name }
   * @returns { Promise<string> } serviceID
   * @throws { ClientError }
   */
  public createService = async ({
    projectID,
    template = "GIT",
    name,
  }: CreateServiceVariables): Promise<string> => {
    try {
      return (
        await this.gqlRequest().request<
          CreateServiceResponse,
          CreateServiceVariables
        >(CREATE_SERVICE, { projectID, template, name })
      ).createService._id;
    } catch (error) {
      if (error instanceof ClientError) {
        console.error(error.response.errors);
        throw error;
      }
      console.error("Unexpected error: ", error);
      throw error;
    }
  };

  /**
   * get all environments with the given projectID
   * @param { GetEnvironmentVariables } { projectID }
   * @returns { Promise<GetEnvironmentResponse> } environments
   * @throws { ClientError }
   */
  public getEnvironments = ({
    projectID,
  }: GetEnvironmentVariables): Promise<GetEnvironmentResponse> => {
    try {
      return this.gqlRequest().request<
        GetEnvironmentResponse,
        GetEnvironmentVariables
      >(GET_ENVIRONMENTS, { projectID });
    } catch (error) {
      if (error instanceof ClientError) {
        console.error(error.response.errors);
        throw error;
      }
      console.error("Unexpected error: ", error);
      throw error;
    }
  };

  /**
   * create a domain, if `isGenerated` is `true`, the domain will be generated by zeabur (e.g. service-name.zeabur.app)
   * @param { CreateDomainVariables } { serviceID, environmentID, domain, isGenerated }
   * @returns { Promise<string> } domain
   * @throws { ClientError }
   */
  public createDomain = async ({
    serviceID,
    environmentID,
    domain,
    isGenerated,
  }: CreateDomainVariables): Promise<string> => {
    try {
      const _domain = isGenerated ? domain.replace(".zeabur.app", "") : domain;
      return (
        await this.gqlRequest().request<
          CreateDomainResponse,
          Omit<CreateDomainVariables, "domain"> & { domain: string }
        >(CREATE_DOMAIN, {
          serviceID,
          environmentID,
          domain: _domain,
          isGenerated,
        })
      ).addDomain.domain;
    } catch (error) {
      if (error instanceof ClientError) {
        console.error(error.response.errors);
        throw error;
      }
      console.error("Unexpected error: ", error);
      throw error;
    }
  };

  public deploy = async ({
    code,
    project,
    service,
    environment,
    domain,
  }: DeployVariables): Promise<DeployResponse> => {
    try {
      const projectID =
        project?.id ?? (await this.createProject({ region: project.region }));
      const serviceID =
        service?.id ??
        (await this.createService({
          projectID,
          template: service?.template,
          name: service.name,
        }));
      const environmentID =
        environment?.id ??
        (await this.getEnvironments({ projectID })).environments[0]._id;

      const formData = new FormData();
      formData.append("environment", environmentID);
      formData.append("code", code, "code.zip");

      await this.request().post(
        `projects/${projectID}/services/${serviceID}/deploy`,
        {
          body: formData,
        }
      );
      
      const domainName =
        domain &&
        // @ts-expect-error
        (await this.createDomain({
          serviceID,
          environmentID,
          domain: domain.name,
          isGenerated: domain.isGenerated,
        }));
      return domainName;
    } catch (error) {
      if (error instanceof HTTPError) {
        console.error(await error.response.json());
        throw error;
      }
      if (error instanceof ClientError) {
        console.error(error.response.errors);
        throw error;
      }
      console.error("Unexpected error: ", error);
      throw error;
    }
  };
}
